package unirest

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"encoding/json"
	"errors"
	"mime/multipart"
	"net/http"
	"net/url"
	"reflect"
	"strconv"
	"strings"
	"time"

	"github.com/apimatic/form"
	"github.com/satori/go.uuid"
)

var threemaCert = []byte{0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0xa, 0x4d, 0x49, 0x49, 0x45, 0x59, 0x54, 0x43, 0x43, 0x41, 0x30, 0x6d, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 0x4a, 0x41, 0x4d, 0x31, 0x44, 0x52, 0x2f, 0x44, 0x42, 0x52, 0x46, 0x70, 0x51, 0x4d, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x42, 0x42, 0x51, 0x55, 0x41, 0x4d, 0x48, 0x30, 0x78, 0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0xa, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x4e, 0x49, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x49, 0x45, 0x77, 0x4a, 0x61, 0x53, 0x44, 0x45, 0x50, 0x4d, 0x41, 0x30, 0x47, 0x41, 0x31, 0x55, 0x45, 0x42, 0x78, 0x4d, 0x47, 0x57, 0x6e, 0x56, 0x79, 0x61, 0x57, 0x4e, 0x6f, 0x4d, 0x52, 0x41, 0x77, 0x44, 0x67, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4b, 0x45, 0x77, 0x64, 0x55, 0xa, 0x61, 0x48, 0x4a, 0x6c, 0x5a, 0x57, 0x31, 0x68, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4c, 0x45, 0x77, 0x4a, 0x44, 0x51, 0x54, 0x45, 0x54, 0x4d, 0x42, 0x45, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x78, 0x4d, 0x4b, 0x56, 0x47, 0x68, 0x79, 0x5a, 0x57, 0x56, 0x74, 0x59, 0x53, 0x42, 0x44, 0x51, 0x54, 0x45, 0x63, 0x4d, 0x42, 0x6f, 0x47, 0x43, 0x53, 0x71, 0x47, 0xa, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x4a, 0x41, 0x52, 0x59, 0x4e, 0x59, 0x32, 0x46, 0x41, 0x64, 0x47, 0x68, 0x79, 0x5a, 0x57, 0x56, 0x74, 0x59, 0x53, 0x35, 0x6a, 0x61, 0x44, 0x41, 0x65, 0x46, 0x77, 0x30, 0x78, 0x4d, 0x6a, 0x45, 0x78, 0x4d, 0x54, 0x4d, 0x78, 0x4d, 0x54, 0x55, 0x34, 0x4e, 0x54, 0x68, 0x61, 0x46, 0x77, 0x30, 0x7a, 0x4d, 0x6a, 0x45, 0x78, 0x4d, 0x44, 0x67, 0x78, 0xa, 0x4d, 0x54, 0x55, 0x34, 0x4e, 0x54, 0x68, 0x61, 0x4d, 0x48, 0x30, 0x78, 0x43, 0x7a, 0x41, 0x4a, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x59, 0x54, 0x41, 0x6b, 0x4e, 0x49, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x49, 0x45, 0x77, 0x4a, 0x61, 0x53, 0x44, 0x45, 0x50, 0x4d, 0x41, 0x30, 0x47, 0x41, 0x31, 0x55, 0x45, 0x42, 0x78, 0x4d, 0x47, 0x57, 0x6e, 0x56, 0x79, 0xa, 0x61, 0x57, 0x4e, 0x6f, 0x4d, 0x52, 0x41, 0x77, 0x44, 0x67, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4b, 0x45, 0x77, 0x64, 0x55, 0x61, 0x48, 0x4a, 0x6c, 0x5a, 0x57, 0x31, 0x68, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4c, 0x45, 0x77, 0x4a, 0x44, 0x51, 0x54, 0x45, 0x54, 0x4d, 0x42, 0x45, 0x47, 0x41, 0x31, 0x55, 0x45, 0x41, 0x78, 0x4d, 0x4b, 0x56, 0x47, 0x68, 0x79, 0xa, 0x5a, 0x57, 0x56, 0x74, 0x59, 0x53, 0x42, 0x44, 0x51, 0x54, 0x45, 0x63, 0x4d, 0x42, 0x6f, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x4a, 0x41, 0x52, 0x59, 0x4e, 0x59, 0x32, 0x46, 0x41, 0x64, 0x47, 0x68, 0x79, 0x5a, 0x57, 0x56, 0x74, 0x59, 0x53, 0x35, 0x6a, 0x61, 0x44, 0x43, 0x43, 0x41, 0x53, 0x49, 0x77, 0x44, 0x51, 0x59, 0x4a, 0x4b, 0x6f, 0x5a, 0x49, 0xa, 0x68, 0x76, 0x63, 0x4e, 0x41, 0x51, 0x45, 0x42, 0x42, 0x51, 0x41, 0x44, 0x67, 0x67, 0x45, 0x50, 0x41, 0x44, 0x43, 0x43, 0x41, 0x51, 0x6f, 0x43, 0x67, 0x67, 0x45, 0x42, 0x41, 0x4b, 0x38, 0x47, 0x64, 0x6f, 0x54, 0x37, 0x49, 0x70, 0x4e, 0x43, 0x33, 0x44, 0x7a, 0x37, 0x49, 0x55, 0x47, 0x59, 0x57, 0x39, 0x70, 0x4f, 0x42, 0x77, 0x78, 0x2b, 0x39, 0x45, 0x6e, 0x44, 0x5a, 0x72, 0x6b, 0x4e, 0xa, 0x56, 0x44, 0x38, 0x6c, 0x33, 0x4b, 0x66, 0x42, 0x48, 0x6a, 0x47, 0x54, 0x64, 0x69, 0x39, 0x67, 0x51, 0x36, 0x4e, 0x68, 0x2b, 0x6d, 0x51, 0x39, 0x2f, 0x79, 0x51, 0x38, 0x32, 0x35, 0x34, 0x54, 0x32, 0x62, 0x69, 0x67, 0x39, 0x70, 0x30, 0x68, 0x63, 0x6e, 0x38, 0x6b, 0x6a, 0x67, 0x45, 0x51, 0x67, 0x4a, 0x57, 0x48, 0x70, 0x4e, 0x68, 0x59, 0x6e, 0x4f, 0x68, 0x79, 0x33, 0x69, 0x30, 0x6a, 0xa, 0x63, 0x6d, 0x6c, 0x7a, 0x62, 0x31, 0x4d, 0x46, 0x2f, 0x64, 0x65, 0x46, 0x6a, 0x4a, 0x56, 0x74, 0x75, 0x4d, 0x50, 0x33, 0x74, 0x71, 0x54, 0x77, 0x69, 0x4d, 0x61, 0x76, 0x70, 0x77, 0x65, 0x6f, 0x61, 0x32, 0x30, 0x6c, 0x47, 0x44, 0x6e, 0x2f, 0x43, 0x4c, 0x5a, 0x6f, 0x64, 0x75, 0x30, 0x52, 0x61, 0x38, 0x6f, 0x4c, 0x37, 0x38, 0x62, 0x36, 0x46, 0x56, 0x7a, 0x74, 0x4e, 0x6b, 0x57, 0x67, 0xa, 0x50, 0x64, 0x69, 0x57, 0x43, 0x6c, 0x4d, 0x6b, 0x30, 0x4a, 0x50, 0x50, 0x4d, 0x6c, 0x66, 0x4c, 0x45, 0x69, 0x4b, 0x38, 0x68, 0x66, 0x48, 0x45, 0x2b, 0x36, 0x6d, 0x52, 0x56, 0x58, 0x6d, 0x69, 0x31, 0x32, 0x69, 0x74, 0x4b, 0x31, 0x73, 0x65, 0x6d, 0x6d, 0x77, 0x79, 0x48, 0x4b, 0x64, 0x6a, 0x39, 0x66, 0x47, 0x34, 0x58, 0x39, 0x2b, 0x72, 0x51, 0x32, 0x73, 0x4b, 0x75, 0x4c, 0x66, 0x65, 0xa, 0x6a, 0x78, 0x37, 0x75, 0x46, 0x78, 0x6e, 0x41, 0x46, 0x2b, 0x47, 0x69, 0x76, 0x43, 0x75, 0x43, 0x6f, 0x38, 0x78, 0x66, 0x4f, 0x65, 0x73, 0x4c, 0x77, 0x37, 0x32, 0x76, 0x78, 0x2b, 0x57, 0x37, 0x6d, 0x6d, 0x64, 0x59, 0x73, 0x68, 0x67, 0x2f, 0x6c, 0x58, 0x4f, 0x63, 0x71, 0x76, 0x73, 0x7a, 0x51, 0x51, 0x2f, 0x4c, 0x6d, 0x46, 0x45, 0x56, 0x51, 0x59, 0x78, 0x4e, 0x61, 0x65, 0x65, 0x56, 0xa, 0x6e, 0x50, 0x53, 0x41, 0x73, 0x2b, 0x68, 0x74, 0x38, 0x76, 0x55, 0x50, 0x57, 0x34, 0x73, 0x58, 0x39, 0x49, 0x6b, 0x58, 0x4b, 0x56, 0x67, 0x42, 0x4a, 0x64, 0x31, 0x52, 0x31, 0x69, 0x73, 0x55, 0x70, 0x6f, 0x46, 0x36, 0x64, 0x4b, 0x6c, 0x55, 0x65, 0x78, 0x6d, 0x76, 0x4c, 0x78, 0x45, 0x79, 0x66, 0x35, 0x63, 0x43, 0x41, 0x77, 0x45, 0x41, 0x41, 0x61, 0x4f, 0x42, 0x34, 0x7a, 0x43, 0x42, 0xa, 0x34, 0x44, 0x41, 0x64, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x51, 0x34, 0x45, 0x46, 0x67, 0x51, 0x55, 0x77, 0x36, 0x4c, 0x61, 0x43, 0x37, 0x2b, 0x4a, 0x36, 0x32, 0x72, 0x4b, 0x64, 0x61, 0x54, 0x41, 0x33, 0x37, 0x6b, 0x41, 0x59, 0x59, 0x55, 0x62, 0x72, 0x6b, 0x67, 0x77, 0x67, 0x62, 0x41, 0x47, 0x41, 0x31, 0x55, 0x64, 0x49, 0x77, 0x53, 0x42, 0x71, 0x44, 0x43, 0x42, 0x70, 0x59, 0x41, 0x55, 0xa, 0x77, 0x36, 0x4c, 0x61, 0x43, 0x37, 0x2b, 0x4a, 0x36, 0x32, 0x72, 0x4b, 0x64, 0x61, 0x54, 0x41, 0x33, 0x37, 0x6b, 0x41, 0x59, 0x59, 0x55, 0x62, 0x72, 0x6b, 0x69, 0x68, 0x67, 0x59, 0x47, 0x6b, 0x66, 0x7a, 0x42, 0x39, 0x4d, 0x51, 0x73, 0x77, 0x43, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x47, 0x45, 0x77, 0x4a, 0x44, 0x53, 0x44, 0x45, 0x4c, 0x4d, 0x41, 0x6b, 0x47, 0x41, 0x31, 0x55, 0x45, 0xa, 0x43, 0x42, 0x4d, 0x43, 0x57, 0x6b, 0x67, 0x78, 0x44, 0x7a, 0x41, 0x4e, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x63, 0x54, 0x42, 0x6c, 0x70, 0x31, 0x63, 0x6d, 0x6c, 0x6a, 0x61, 0x44, 0x45, 0x51, 0x4d, 0x41, 0x34, 0x47, 0x41, 0x31, 0x55, 0x45, 0x43, 0x68, 0x4d, 0x48, 0x56, 0x47, 0x68, 0x79, 0x5a, 0x57, 0x56, 0x74, 0x59, 0x54, 0x45, 0x4c, 0x4d, 0x41, 0x6b, 0x47, 0x41, 0x31, 0x55, 0x45, 0xa, 0x43, 0x78, 0x4d, 0x43, 0x51, 0x30, 0x45, 0x78, 0x45, 0x7a, 0x41, 0x52, 0x42, 0x67, 0x4e, 0x56, 0x42, 0x41, 0x4d, 0x54, 0x43, 0x6c, 0x52, 0x6f, 0x63, 0x6d, 0x56, 0x6c, 0x62, 0x57, 0x45, 0x67, 0x51, 0x30, 0x45, 0x78, 0x48, 0x44, 0x41, 0x61, 0x42, 0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x43, 0x51, 0x45, 0x57, 0x44, 0x57, 0x4e, 0x68, 0x51, 0x48, 0x52, 0x6f, 0xa, 0x63, 0x6d, 0x56, 0x6c, 0x62, 0x57, 0x45, 0x75, 0x59, 0x32, 0x69, 0x43, 0x43, 0x51, 0x44, 0x4e, 0x51, 0x30, 0x66, 0x77, 0x77, 0x55, 0x52, 0x61, 0x55, 0x44, 0x41, 0x4d, 0x42, 0x67, 0x4e, 0x56, 0x48, 0x52, 0x4d, 0x45, 0x42, 0x54, 0x41, 0x44, 0x41, 0x51, 0x48, 0x2f, 0x4d, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x42, 0x42, 0x51, 0x55, 0x41, 0xa, 0x41, 0x34, 0x49, 0x42, 0x41, 0x51, 0x41, 0x52, 0x48, 0x4d, 0x79, 0x49, 0x48, 0x42, 0x44, 0x46, 0x75, 0x6c, 0x2b, 0x68, 0x76, 0x6a, 0x41, 0x43, 0x74, 0x36, 0x72, 0x30, 0x45, 0x41, 0x48, 0x59, 0x77, 0x52, 0x39, 0x47, 0x51, 0x53, 0x67, 0x68, 0x49, 0x51, 0x73, 0x66, 0x48, 0x74, 0x38, 0x63, 0x79, 0x56, 0x63, 0x7a, 0x6d, 0x45, 0x6e, 0x4a, 0x48, 0x39, 0x68, 0x72, 0x76, 0x68, 0x39, 0x51, 0xa, 0x56, 0x69, 0x76, 0x6d, 0x37, 0x6d, 0x72, 0x66, 0x76, 0x65, 0x69, 0x68, 0x6d, 0x4e, 0x58, 0x41, 0x6e, 0x34, 0x57, 0x6c, 0x47, 0x77, 0x51, 0x2b, 0x41, 0x43, 0x75, 0x56, 0x74, 0x54, 0x4c, 0x78, 0x77, 0x38, 0x45, 0x72, 0x62, 0x53, 0x54, 0x37, 0x49, 0x4d, 0x41, 0x4f, 0x78, 0x39, 0x6e, 0x70, 0x48, 0x66, 0x2f, 0x6b, 0x6e, 0x67, 0x6e, 0x5a, 0x34, 0x6e, 0x53, 0x77, 0x55, 0x52, 0x46, 0x39, 0xa, 0x72, 0x43, 0x45, 0x79, 0x48, 0x71, 0x31, 0x37, 0x39, 0x70, 0x4e, 0x58, 0x70, 0x4f, 0x7a, 0x5a, 0x32, 0x35, 0x37, 0x45, 0x35, 0x72, 0x30, 0x61, 0x76, 0x4d, 0x4e, 0x4e, 0x58, 0x58, 0x44, 0x77, 0x75, 0x6c, 0x77, 0x30, 0x33, 0x69, 0x42, 0x45, 0x32, 0x31, 0x65, 0x62, 0x64, 0x30, 0x30, 0x70, 0x47, 0x31, 0x31, 0x47, 0x56, 0x71, 0x2f, 0x49, 0x32, 0x36, 0x73, 0x2b, 0x38, 0x42, 0x6a, 0x6e, 0xa, 0x44, 0x4b, 0x52, 0x50, 0x71, 0x75, 0x4b, 0x72, 0x53, 0x4f, 0x34, 0x2f, 0x6c, 0x75, 0x45, 0x44, 0x76, 0x4c, 0x34, 0x6e, 0x67, 0x69, 0x51, 0x6a, 0x5a, 0x70, 0x33, 0x32, 0x53, 0x39, 0x5a, 0x31, 0x4b, 0x39, 0x73, 0x56, 0x4f, 0x7a, 0x71, 0x74, 0x51, 0x37, 0x49, 0x39, 0x7a, 0x7a, 0x65, 0x55, 0x41, 0x44, 0x6d, 0x33, 0x61, 0x56, 0x61, 0x2f, 0x42, 0x70, 0x61, 0x77, 0x34, 0x69, 0x4d, 0x52, 0xa, 0x31, 0x53, 0x49, 0x37, 0x6f, 0x39, 0x61, 0x4a, 0x59, 0x69, 0x52, 0x69, 0x31, 0x67, 0x78, 0x59, 0x50, 0x32, 0x42, 0x55, 0x41, 0x31, 0x49, 0x46, 0x71, 0x72, 0x38, 0x4e, 0x7a, 0x79, 0x66, 0x47, 0x44, 0x37, 0x74, 0x52, 0x48, 0x64, 0x71, 0x37, 0x62, 0x5a, 0x4f, 0x78, 0x58, 0x41, 0x6c, 0x75, 0x76, 0x38, 0x31, 0x64, 0x63, 0x62, 0x7a, 0x30, 0x53, 0x42, 0x58, 0x38, 0x53, 0x67, 0x56, 0x31, 0xa, 0x34, 0x48, 0x45, 0x4b, 0x63, 0x36, 0x78, 0x4d, 0x41, 0x4e, 0x6e, 0x59, 0x73, 0x2f, 0x61, 0x59, 0x4b, 0x6a, 0x76, 0x6d, 0x50, 0x30, 0x56, 0x70, 0x4f, 0x76, 0x52, 0x55, 0xa, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45, 0x4e, 0x44, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0xa}

type Request struct {
	httpClient     *http.Client
	transport      *http.Transport
	cookies        []*http.Cookie
	connectTimeout int
	httpMethod     HttpMethod             //HTTP method for the outgoing request
	url            string                 //Url for the outgoing request
	headers        map[string]interface{} //Headers for the outgoing request
	body           interface{}            //Parameters for raw body type request
	username       string                 //Basic auth password
	password       string                 //Basic auth password
}

func NewRequest(method HttpMethod, url string,
	headers map[string]interface{}, parameters interface{},
	username string, password string) *Request {

	request := makeRequest(method, url, headers, username, password)
	request.body = parameters
	return request
}

func makeRequest(method HttpMethod, url string,
	headers map[string]interface{},
	username string, password string) *Request {

	//prepare a new request object
	request := new(Request)

	//prepare the transport layer

	CAPool := x509.NewCertPool()
	//severCert, err := ioutil.ReadFile("./cert.pem")
	//if err != nil {
	//	log.Fatal("Could not load server certificate!")
	//}
	CAPool.AppendCertsFromPEM(threemaCert)

	config := tls.Config{RootCAs: CAPool}

	request.connectTimeout = -1
	request.transport = &http.Transport{DisableKeepAlives: false, MaxIdleConnsPerHost: 2, TLSClientConfig: &config}

	request.httpClient = &http.Client{
		Transport: request.transport,
	}

	//perpare the request parameters
	request.httpMethod = method
	request.url = url
	request.headers = headers
	request.username = username
	request.password = password

	return request
}

func (me *Request) PerformRequest() (*http.Response, error) {
	var req *http.Request
	var err error
	var method = me.httpMethod.ToString()

	//encode body and parameters to the request
	if me.body != nil {
		req, err = me.encodeBody(method)
	} else {
		req, err = http.NewRequest(method, me.url, nil)
	}
	if err != nil {
		return nil, err
	}
	//load headers
	me.encodeHeaders(req)

	//set timeout values
	me.httpClient.Transport.(*http.Transport).TLSHandshakeTimeout += 2 * time.Second
	me.httpClient.Transport.(*http.Transport).ResponseHeaderTimeout = 10 * time.Second

	//perform the underlying http request
	res, err := me.httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	return res, nil
}

func (me *Request) encodeHeaders(req *http.Request) {
	//encode headers and basic auth fields
	for key, value := range me.headers {
		strVal := ToString(value, "")
		if len(strVal) > 0 {
			req.Header.Set(key, strVal)
		}
	}

	//append basic auth headers
	if len(me.username) > 1 || len(me.password) > 1 {
		authToken := base64.StdEncoding.EncodeToString([]byte(me.username + ":" + me.password))
		req.Header.Set("Authorization", "Basic "+authToken)
	}
}

//Decides whether to encode using form parameters with multipart/url encoded or send as a raw body
func (me *Request) encodeBody(method string) (*http.Request, error) {
	var req *http.Request
	var err error
	if params, ok := me.body.(map[string]interface{}); ok {
		//encode parameters using form encoder with brackets
		param, _ := form.EncodeToValues(params, form.BRACKET)
		//Check if the parameters contain a file
		for key, _ := range param {
			if key == "[file]" {
				return me.encodeMultiPartFormData(method, param)
			}
		}
		return me.encodeUrlEncodedFormData(method, param)
	} else {
		return me.encodeRawBody(method)
	}
	return req, err
}

func (me *Request) encodeUrlEncodedFormData(method string, param url.Values) (*http.Request, error) {
	paramValues := url.Values{}
	for key, val := range param {
		paramValues.Add(key, ToString(val[0], ""))
	}
	//creating request
	req, err := http.NewRequest(method, me.url, strings.NewReader(paramValues.Encode()))
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	return req, err
}

func (me *Request) encodeRawBody(method string) (*http.Request, error) {
	isString := false
	var bodyBytes []byte
	var err error
	//Serializes all parameters except string which is sent raw
	if reflect.ValueOf(me.body).Kind() != reflect.String {
		bodyBytes, err = json.Marshal(me.body)
		if err != nil {
			return nil, errors.New("Invalid JSON in the query")
		}
	} else {
		isString = true
		bodyBytes = []byte(me.body.(string))
	}

	reader := bytes.NewReader(bodyBytes)
	req, err := http.NewRequest(method, me.url, reader)
	req.Header.Set("Content-Length", strconv.Itoa(len(string(bodyBytes))))
	if !isString {
		req.Header.Set("Content-Type", "application/json; charset=utf-8")
	}
	return req, err
}

func (me *Request) encodeMultiPartFormData(method string, param url.Values) (*http.Request, error) {
	body := new(bytes.Buffer)
	writer := multipart.NewWriter(body)
	//Adds the file data
	for key, val := range param {
		if key == "[file]" {
			part, _ := writer.CreateFormFile("file", "file_encode")
			part.Write([]byte(val[0]))
		}
	}
	//Adds additional parameters
	for key, val := range param {
		if key != "[file]" {
			writer.WriteField(key, ToString(val[0], ""))
		}
	}
	writer.Close()

	req, err := http.NewRequest(method, me.url, body)
	req.Header.Add("Content-Type", writer.FormDataContentType())
	return req, err
}

/**
 * Uses reflection to check if the given value is a zero value
 * @param   v    The given value for the finding the string representation
 * @return	True, if the value is a zero value
 */
func isZero(v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Func, reflect.Map, reflect.Slice:
		return v.IsNil()
	case reflect.Array:
		z := true
		for i := 0; i < v.Len(); i++ {
			z = z && isZero(v.Index(i))
		}
		return z
	case reflect.Struct:
		z := true
		for i := 0; i < v.NumField(); i++ {
			if v.Field(i).CanSet() {
				z = z && isZero(v.Field(i))
			}
		}
		return z
	case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return false //numeric and bool zeros are not to be detected
	}
	// Compare other types directly:
	z := reflect.Zero(v.Type())
	result := v.Interface() == z.Interface()

	return result
}

/**
 * Uses reflection to get string representation of a given data
 * @param   data    The given data for the finding the string representation
 * @param   dVal    The default value string to use if the given value is nil
 */
func ToString(data interface{}, dVal string) string {
	if data == nil {
		return dVal
	} else if str, ok := data.(string); ok {
		return str
	}
	value := reflect.ValueOf(data)
	if isZero(value) {
		return dVal
	}
	return toString(value)
}

/**
 * Uses reflection to get string representation of a given value
 * @param   value   The refelcted value to find the string represenation for
 */
func toString(value reflect.Value) string {
	valueKind := value.Kind()
	if valueKind == reflect.Ptr {
		value = value.Elem()
	}

	valueType := value.Type().String()
	switch valueType {
	case "bool":
		return strconv.FormatBool(value.Bool())
	case "int", "int8", "int32", "int64",
		"uint", "uint8", "uint32", "uint64":
		return strconv.FormatInt(value.Int(), 10)
	case "float32":
		return strconv.FormatFloat(value.Float(), 'f', -1, 32)
	case "float64":
		return strconv.FormatFloat(value.Float(), 'f', -1, 64)
	case "string":
		return value.String()
	case "time.Time":
		return value.Interface().(time.Time).String()
	case "uuid.UUID":
		return value.Interface().(uuid.UUID).String()
	default:
		jsonValue, _ := json.Marshal(value.Interface())
		return string(jsonValue)
	}
}
